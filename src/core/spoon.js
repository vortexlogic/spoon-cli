#!/usr/bin/env node

const { Command } = require('commander');
const readline = require('readline');
const fs = require('fs');
const path = require('path');
const { exec, spawn, execSync } = require('child_process');
const os = require('os');
const { GoogleGenerativeAI } = require('@google/generative-ai');

const program = new Command();

// Professional Color Scheme - Green & White Only
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  white: '\x1b[37m'
};

program
  .name('spoon')
  .description('    ' + colors.white + '███████╗██████╗  ██████╗  ██████╗ ███╗   ██╗' + colors.reset + '\n' +
               '    ' + colors.white + '██╔════╝██╔══██╗██╔═══██╗██╔═══██╗████╗  ██║' + colors.reset + '\n' +
               '    ' + colors.white + '███████╗██████╔╝██║   ██║██║   ██║██╔██╗ ██║' + colors.reset + '\n' +
               '    ' + colors.white + '╚════██║██╔═══╝ ██║   ██║██║   ██║██║╚██╗██║' + colors.reset + '\n' +
               '    ' + colors.white + '███████║██║     ╚██████╔╝╚██████╔╝██║ ╚████║' + colors.reset + '\n' +
               '    ' + colors.white + '╚══════╝╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝' + colors.reset + '\n\n' +
               colors.white + 'VORTEXLOGIC META-CLI v5.0' + colors.reset + '\n' +
               colors.green + 'Terminal Automation Platform' + colors.reset)
  .version('5.0.0-ENTERPRISE')
  .option('--profile <type>', 'Execution profile', 'dev')
  .option('--dry-run', 'Preview operations')
  .option('--verbose', 'Enable logging')
  .option('--gemini-key <key>', 'Gemini AI Key', 'AIzaSyCYWfwV3uRtqXMGZGou3LxcAQ7r5o6CBBs');

// ========== GEMINI AI INTEGRATION ==========
class GeminiAI {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.genAI = new GoogleGenerativeAI(this.apiKey);
    this.model = this.genAI.getGenerativeModel({ 
      model: "gemini-2.0-flash-exp",
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 1024,
      }
    });
  }

  async chat(prompt, context = '') {
    try {
      const fullPrompt = context + '\n\nUser: ' + prompt + '\n\nYou are SPOON META-CLI, a professional terminal automation system. You automate web development, software creation, and deployment to GitHub, Vercel, and other platforms. Provide concise, actionable responses.';
      
      const result = await this.model.generateContent(fullPrompt);
      const response = await result.response;
      return {
        success: true,
        response: response.text()
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        fallback: this.getFallbackResponse(prompt)
      };
    }
  }

  getFallbackResponse(prompt) {
    return colors.green + 'SPOON: I understand "' + prompt + '". My AI is optimizing. I can automate: web apps, software projects, GitHub deployments, Vercel hosting, and terminal workflows.' + colors.reset;
  }
}

// ========== PROJECT AUTOMATION ENGINE ==========
class ProjectAutomation {
  constructor() {
    this.templates = {
      'webapp': this.getWebAppTemplate(),
      'react-app': this.getReactTemplate()
    };
  }

  getWebAppTemplate() {
    return {
      structure: [
        'index.html',
        'styles/',
        'scripts/',
        'assets/',
        'README.md'
      ],
      files: {
        'index.html': `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPOON Generated App</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <div class="container">
        <h1>Welcome to Your SPOON App</h1>
        <p>Automatically generated by SPOON META-CLI</p>
        <button id="cta-button">Get Started</button>
    </div>
    <script src="scripts/app.js"></script>
</body>
</html>`,
        'styles/main.css': `* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
}

.container {
    background: white;
    padding: 3rem;
    border-radius: 15px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    text-align: center;
    max-width: 500px;
}

h1 {
    color: #2d3748;
    margin-bottom: 1rem;
    font-size: 2.5rem;
}

p {
    color: #718096;
    margin-bottom: 2rem;
    font-size: 1.1rem;
}

#cta-button {
    background: #4299e1;
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.3s;
}

#cta-button:hover {
    background: #3182ce;
}`,
        'scripts/app.js': `document.getElementById('cta-button').addEventListener('click', function() {
    alert('SPOON META-CLI - Your app is working!');
});`,
        'README.md': `# SPOON Generated Web Application
    
This project was automatically generated by SPOON META-CLI.

## Features
- Responsive design
- Modern CSS with gradients
- Interactive JavaScript
- Professional structure

## Deployment
Use SPOON to deploy:
\`\`\`bash
spoon deploy github
spoon deploy vercel
\`\`\``
      }
    };
  }

  getReactTemplate() {
    return {
      structure: [
        'src/',
        'public/',
        'package.json',
        'README.md'
      ],
      files: {
        'package.json': `{
  "name": "spoon-react-app",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.0.0",
    "vite": "^4.4.0"
  }
}`,
        'src/main.jsx': `import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)`,
        'src/App.jsx': `import { useState } from 'react'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    <div className="App">
      <h1>SPOON React App</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          Count is {count}
        </button>
        <p>
          Edit <code>src/App.jsx</code> and save to test HMR
        </p>
      </div>
    </div>
  )
}

export default App`
      }
    };
  }

  createProject(name, type, options = {}) {
    const template = this.templates[type] || this.templates.webapp;
    const projectPath = path.join(process.cwd(), name);
    
    // Create project directory
    if (!fs.existsSync(projectPath)) {
      fs.mkdirSync(projectPath, { recursive: true });
    }

    // Create directory structure
    template.structure.forEach(item => {
      const itemPath = path.join(projectPath, item);
      if (item.endsWith('/')) {
        if (!fs.existsSync(itemPath)) {
          fs.mkdirSync(itemPath, { recursive: true });
        }
      }
    });

    // Create files
    Object.entries(template.files).forEach(([filePath, content]) => {
      const fullPath = path.join(projectPath, filePath);
      const dir = path.dirname(fullPath);
      
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(fullPath, content);
    });

    return {
      success: true,
      path: projectPath,
      type: type,
      files: Object.keys(template.files).length,
      message: 'Project created successfully'
    };
  }

  // Deployment automation
  async deployToGitHub(projectPath, repoName) {
    try {
      const commands = [
        'cd "' + projectPath + '"',
        'git init',
        'git add .',
        'git commit -m "Initial commit from SPOON META-CLI"',
        'gh repo create ' + repoName + ' --public --push'
      ];

      execSync(commands.join(' && '), { stdio: 'inherit' });
      return { success: true, url: 'https://github.com/' + this.getGitHubUsername() + '/' + repoName };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async deployToVercel(projectPath) {
    try {
      const commands = [
        'cd "' + projectPath + '"',
        'npx vercel --prod --yes'
      ];

      execSync(commands.join(' && '), { stdio: 'inherit' });
      return { success: true, message: 'Deployed to Vercel' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  getGitHubUsername() {
    try {
      const output = execSync('gh api user', { encoding: 'utf8' });
      const user = JSON.parse(output);
      return user.login;
    } catch (error) {
      return 'username';
    }
  }
}

// ========== SPOON META-CLI CORE ==========
class SpoonMetaCLI {
  constructor(geminiApiKey) {
    this.gemini = new GeminiAI(geminiApiKey);
    this.automation = new ProjectAutomation();
    this.session = {
      user: this.getSystemUser(),
      projects: []
    };
  }

  getSystemUser() {
    return os.userInfo().username;
  }

  async processCommand(input) {
    const context = this.buildContext();
    const aiResponse = await this.gemini.chat(input, context);
    
    if (aiResponse.success) {
      return this.formatResponse(aiResponse.response);
    } else {
      return this.handleAutomationRequest(input, aiResponse.fallback);
    }
  }

  buildContext() {
    return 'SPOON META-CLI CONTEXT:\n' +
           '- User: ' + this.session.user + '\n' +
           '- Project Templates: ' + 'webapp, react-app' + '\n' +
           '- Deployment Targets: GitHub, Vercel\n\n' +
           'Capabilities:\n' +
           '- Automate web application creation\n' +
           '- Generate software projects\n' +
           '- Deploy to multiple platforms\n' +
           '- Execute terminal commands\n\n' +
           'Respond as a professional automation system. Focus on actionable steps and technical solutions.';
  }

  formatResponse(text) {
    return colors.green + text + colors.reset;
  }

  handleAutomationRequest(input, fallback) {
    const lowerInput = input.toLowerCase();

    // Project creation requests
    if (lowerInput.includes('create') && lowerInput.includes('project')) {
      const projectType = this.extractProjectType(input);
      const projectName = this.extractProjectName(input) || 'my-app';
      
      const result = this.automation.createProject(projectName, projectType);
      this.session.projects.push(result);
      
      return colors.green + 'PROJECT CREATED: ' + projectName + colors.reset + '\n' +
             colors.white + 'Type: ' + projectType + colors.reset + '\n' +
             colors.white + 'Path: ' + result.path + colors.reset + '\n' +
             colors.white + 'Files: ' + result.files + colors.reset + '\n\n' +
             colors.green + 'Next: Use spoon deploy github or spoon deploy vercel' + colors.reset;
    }

    // Deployment requests
    if (lowerInput.includes('deploy') || lowerInput.includes('publish')) {
      const target = this.extractDeploymentTarget(input);
      return this.handleDeployment(target);
    }

    return fallback;
  }

  extractProjectType(input) {
    if (input.includes('react')) return 'react-app';
    if (input.includes('node') || input.includes('api')) return 'node-api';
    return 'webapp';
  }

  extractProjectName(input) {
    const words = input.split(' ');
    const createIndex = words.findIndex(word => word.toLowerCase() === 'create');
    if (createIndex !== -1 && words[createIndex + 1]) {
      return words[createIndex + 1];
    }
    return null;
  }

  extractDeploymentTarget(input) {
    if (input.includes('github')) return 'github';
    if (input.includes('vercel')) return 'vercel';
    return 'github';
  }

  handleDeployment(target) {
    const latestProject = this.session.projects[this.session.projects.length - 1];
    
    if (!latestProject) {
      return colors.green + 'No project found. Create a project first:' + colors.reset + '\n' +
             colors.white + 'spoon project create my-project' + colors.reset + '\n' +
             colors.white + 'spoon project create my-app --type react-app' + colors.reset;
    }

    return colors.green + 'DEPLOYMENT INITIATED: ' + target.toUpperCase() + colors.reset + '\n' +
           colors.white + 'Project: ' + latestProject.path + colors.reset + '\n' +
           colors.white + 'Target: ' + target + colors.reset + '\n\n' +
           colors.green + 'Run: spoon deploy ' + target + ' --confirm' + colors.reset;
  }

  // Public methods for command execution
  createProject(name, type) {
    return this.automation.createProject(name, type);
  }

  async deployProject(target, projectPath) {
    switch (target) {
      case 'github':
        return await this.automation.deployToGitHub(projectPath, path.basename(projectPath));
      case 'vercel':
        return await this.automation.deployToVercel(projectPath);
      default:
        return { success: false, error: 'Unknown deployment target' };
    }
  }
}

// ========== PROFESSIONAL CHAT INTERFACE ==========
class ProfessionalChat {
  constructor(geminiApiKey) {
    this.spoon = new SpoonMetaCLI(geminiApiKey);
    this.setupReadline();
  }

  setupReadline() {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: colors.white + 'USER: ' + colors.reset
    });
  }

  async start() {
    this.displayWelcome();
    this.rl.prompt();
    
    this.rl.on('line', async (input) => {
      const trimmedInput = input.trim();
      
      if (trimmedInput.toLowerCase() === 'exit') {
        console.log(colors.green + 'SPOON: Session terminated.' + colors.reset);
        this.rl.close();
        return;
      }
      
      if (trimmedInput === '') {
        this.rl.prompt();
        return;
      }

      console.log(colors.green + 'SPOON: Processing...' + colors.reset);
      
      try {
        const response = await this.spoon.processCommand(trimmedInput);
        console.log('\n' + response + '\n');
      } catch (error) {
        console.log(colors.green + 'SPOON: Error - ' + error.message + colors.reset);
      }
      
      this.rl.prompt();
    });

    this.rl.on('close', () => {
      console.log(colors.green + 'SPOON: Automation session complete.' + colors.reset);
      process.exit(0);
    });
  }

  displayWelcome() {
    console.log('\n    ' + colors.white + '███████╗██████╗  ██████╗  ██████╗ ███╗   ██╗' + colors.reset);
    console.log('    ' + colors.white + '██╔════╝██╔══██╗██╔═══██╗██╔═══██╗████╗  ██║' + colors.reset);
    console.log('    ' + colors.white + '███████╗██████╔╝██║   ██║██║   ██║██╔██╗ ██║' + colors.reset);
    console.log('    ' + colors.white + '╚════██║██╔═══╝ ██║   ██║██║   ██║██║╚██╗██║' + colors.reset);
    console.log('    ' + colors.white + '███████║██║     ╚██████╔╝╚██████╔╝██║ ╚████║' + colors.reset);
    console.log('    ' + colors.white + '╚══════╝╚═╝      ╚═════╝  ╚═════╝ ╚═╝  ╚═══╝' + colors.reset);
    console.log('\n' + colors.white + 'VORTEXLOGIC META-CLI v5.0' + colors.reset);
    console.log(colors.green + 'Terminal Automation Platform' + colors.reset + '\n');
    console.log(colors.white + 'Automation Systems: ACTIVE' + colors.reset);
    console.log(colors.green + 'Ready for project creation and deployment' + colors.reset + '\n');
  }
}

// ========== SPOON COMMANDS ==========
const chat = program.command('chat').description('Professional automation interface');

chat.action(() => {
  const geminiKey = program.opts().geminiKey;
  const chatInterface = new ProfessionalChat(geminiKey);
  chatInterface.start();
});

// Project Commands
const project = program.command('project').description('Project automation');

project.command('create <name>')
  .description('Create new project')
  .option('--type <type>', 'Project type (webapp, react-app)', 'webapp')
  .action((name, options) => {
    const spoon = new SpoonMetaCLI(program.opts().geminiKey);
    const result = spoon.createProject(name, options.type);
    
    console.log(colors.green + 'PROJECT CREATED: ' + name + colors.reset);
    console.log(colors.white + 'Type: ' + options.type + colors.reset);
    console.log(colors.white + 'Path: ' + result.path + colors.reset);
    console.log(colors.white + 'Files: ' + result.files + colors.reset);
    console.log(colors.green + 'Ready for deployment' + colors.reset);
  });

// Deployment Commands
const deploy = program.command('deploy').description('Deployment automation');

deploy.command('github [project]')
  .description('Deploy to GitHub')
  .action(async (projectDir) => {
    const spoon = new SpoonMetaCLI(program.opts().geminiKey);
    const projectPath = projectDir || process.cwd();
    const result = await spoon.deployProject('github', projectPath);
    
    if (result.success) {
      console.log(colors.green + 'DEPLOYED TO GITHUB' + colors.reset);
      console.log(colors.white + 'URL: ' + result.url + colors.reset);
    } else {
      console.log(colors.green + 'DEPLOYMENT FAILED: ' + result.error + colors.reset);
    }
  });

deploy.command('vercel [project]')
  .description('Deploy to Vercel')
  .action(async (projectDir) => {
    const spoon = new SpoonMetaCLI(program.opts().geminiKey);
    const projectPath = projectDir || process.cwd();
    const result = await spoon.deployProject('vercel', projectPath);
    
    if (result.success) {
      console.log(colors.green + 'DEPLOYED TO VERCEL' + colors.reset);
    } else {
      console.log(colors.green + 'DEPLOYMENT FAILED: ' + result.error + colors.reset);
    }
  });

// System Commands
program.command('status')
  .description('System status')
  .action(() => {
    const spoon = new SpoonMetaCLI(program.opts().geminiKey);
    console.log(colors.white + 'SPOON META-CLI STATUS' + colors.reset);
    console.log(colors.green + 'Automation: ACTIVE' + colors.reset);
    console.log(colors.green + 'AI Integration: OPERATIONAL' + colors.reset);
    console.log(colors.green + 'Deployment Targets: READY' + colors.reset);
    console.log(colors.white + 'User: ' + spoon.session.user + colors.reset);
  });

program.parse(process.argv);
